
## 4.3.1 运算符

运算符：对常量或者变量进行操作的符号

表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式。

举例说明：

```java
 int a = 10;
 int b = 20;
 int c = a + b;
```

+：是运算符，并且是算术运算符

a + b：是表达式，由于 + 是算术运算符，所以这个表达式叫算术表达式

### 4.3.1.1 算术运算符

| 符号 | 作用 |             说明             |
| :--: | :--: | :--------------------------: |
|  +   |  加  |        参看小学一年级        |
|  -   |  减  |        参看小学一年级        |
|  *   |  乘  |  参看小学二年级，与"×"相同   |
|  /   |  除  |  参看小学二年级，与"÷"相同   |
|  %   | 取余 | 获取的是两个数据做除法的余数 |

注意事项：

1. / 和 % 的区别：两个数据做除法，/ 取结果的商，% 取结果的余数。
2. 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。
3. 字符的 "+" 操作：

拿字符在计算机底层对应的数值来进行计算的

![image-20201231112634331](https://gitee.com/zgf1366/pic_store/raw/master/img/20210206135322.png)

'a' -- 97 a-z是连续的，所以'b'对应的数值是98，'c'是99，依次递加
'A' -- 65 A-Z是连续的，所以'B'对应的数值是66，'C'是67，依次递加
'0' -- 48 0-9是连续的，所以'1'对应的数值是49，'2'是50，依次递加

```java
// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少
char ch1 = 'a';
System.out.println(ch1 + 1); // 输出98，97 + 1 = 98
char ch2 = 'A';
System.out.println(ch2 + 1); // 输出66，65 + 1 = 66
char ch3 = '0';
System.out.println(ch3 + 1); // 输出49，48 + 1 = 49
```

算术表达式中包含多个基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。

提升规则：

- byte类型，short类型和char类型将被提升到int类型

- 整个表达式的类型自动提升到表达式中最高等级操作数同样的类型

    等级顺序：byte,short,char -> int -> long -> float -> double

```java
byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度
int i3 = b1 + b2; // 应该使用int接收
byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型
int num1 = 10;
double num2 = 20.0;
double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型
```

tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。

当 "+" 操作中出现字符串时，这个 "+" 是字符串连接符，而不是算术运算。

```java
System.out.println("itheima"+ 666); // 输出：itheima666
```

在 "+" 操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行 "+" 操作时，从左到右逐个执行。

```java
System.out.println(1 + 99 + "年黑马"); // 输出：199年黑马
System.out.println(1 + 2 + "itheima" + 3 + 4); // 输出：3itheima34
// 可以使用小括号改变运算的优先级
System.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7
```

### 4.3.1.2 赋值运算符

| 符号 |    作用    |            说明            |
| :--: | :--------: | :------------------------: |
|  =   |    赋值    | a = 10，将 10 赋值给变量a  |
|  +=  |  加后赋值  |  a += b，将 a + b 的值给a  |
|  -=  |  减后赋值  |  a -= b，将 a - b 的值给a  |
|  *=  |  乘后赋值  |  a *= b，将 a × b 的值给a  |
|  /=  |  除后赋值  |  a /= b，将 a ÷ b 的商给a  |
|  %=  | 取余后赋值 | a %= b，将a ÷  b 的余数给a |

**注意事项：**

扩展的赋值运算符隐含了强制类型转换

```java
short s = 10;
s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度
s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);
```

### 4.3.1.3 自增自减运算符

| 符号 | 作用 |    说明     |
| :--: | :--: | :---------: |
|  ++  | 自增 | 变量的值加1 |
|  --  | 自减 | 变量的值减1 |

**注意事项：**

- ++ 和 -- 既可以放在变量的后边，也可以放在变量的前边。
- 单独使用的时候， ++ 和 -- 无论是放在变量的前边还是后边，结果是一样的。
- 参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做 ++ 或者 --。
- 参与操作的时候，如果放在变量的前边，先拿变量做 ++ 或者 --，后拿变量参与操作。
- 最常见的用法：单独使用

```java
int i = 10;
i++; // 单独使用
System.out.println("i:" + i); // i:11
int j = 10;
++j; // 单独使用
System.out.println("j:" + j); // j:11
int x = 10;
int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1
System.out.println("x:" + x + ", y:" + y); // x:11，y:10
int m = 10;
int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1
System.out.println("m:" + m + ", m:" + m); // m:11，m:11
```

练习：

```java
int x = 10;
int y = x++ + x++ + x++;
System.out.println(y); // y的值是多少？
/*
解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是
10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。
所以整个式子应该是：int y = 10 + 11 + 12;
输出结果为33。
*/
注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！
```

### 4.3.1.4 关系运算符

| 符号 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  ==  | a == b，判断 a 和 b 的值是否相等，成立为true，不成立为false  |
|  !=  | a != b，判断 a 和 b 的值是否不相等，成立为true，不成立为false |
|  >   |     a > b，判断 a 是否大于 b，成立为true，不成立为false      |
|  >=  |   a >= b，判断 a 是否大于等于 b，成立为true，不成立为false   |
|  <   |     a < b，判断 a 是否小于 b，成立为true，不成立为false      |
|  <=  |   a <= b，判断 a 是否小于等于 b，成立为true，不成立为false   |

**注意事项：**

关系运算符的结果都是boolean类型，要么是true，要么是false。

千万不要把 "==" 误写成 "="。

```java
int a = 10;
int b = 20;
System.out.println(a == b); // false
System.out.println(a != b); // true
System.out.println(a > b); // false
System.out.println(a >= b); // false
System.out.println(a < b); // true
System.out.println(a <= b); // true
// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量
boolean flag = a > b;
System.out.println(flag); // 输出false
```

### 4.3.1.5 逻辑运算符

逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。

在数学中，一个数据x，大于3，小于6，我们可以这样来进行表示： 3<x<6 。

在Java中，需要把上面的式子先进行拆解，再进行合并表达。

拆解为： x > 3 和 x < 6 

合并后： x > 3 && x < 6 

&& 其实就是一个逻辑运算符。

我们可以这样说，逻辑运算符，是用来连接关系表达式的运算符。当然，逻辑运算符也可以直接连接布尔类型的常量或者变量。

| 符号 |   作用   |                       说明                        |
| :--: | :------: | :-----------------------------------------------: |
|  &   |  逻辑与  |  a & b，a 和 b 都是true，结果为true，否则为false  |
|  \|  |  逻辑或  | a \| b，a 和 b 都是false，结果为false，否则为true |
|  ^   | 逻辑异或 |     a ^ b，a 和 b 结果不同为true，相同为false     |
|  !   |  逻辑非  |            !a，结果和 a 的结果正好相反            |

```java
//定义变量
int i = 10;
int j = 20;
int k = 30;
//& “与”，并且的关系，只要表达式中有一个值为false，结果即为false
System.out.println((i > j) & (i > k)); //false & false,输出false
System.out.println((i < j) & (i > k)); //true & false,输出false
System.out.println((i > j) & (i < k)); //false & true,输出false
System.out.println((i < j) & (i < k)); //true & true,输出true
System.out.println("--------");
//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true
System.out.println((i > j) | (i > k)); //false | false,输出false
System.out.println((i < j) | (i > k)); //true | false,输出true
System.out.println((i > j) | (i < k)); //false | true,输出true
System.out.println((i < j) | (i < k)); //true | true,输出true
System.out.println("--------");
//^ “异或”，相同为false，不同为true
System.out.println((i > j) ^ (i > k)); //false ^ false,输出false
System.out.println((i < j) ^ (i > k)); //true ^ false,输出true
System.out.println((i > j) ^ (i < k)); //false ^ true,输出true
System.out.println((i < j) ^ (i < k)); //true ^ true,输出false
System.out.println("--------");
//! “非”，取反
System.out.println((i > j)); //false
System.out.println(!(i > j)); //!false，,输出true
```

**短路逻辑运算符**

| 符号 |  作用  |             说明             |
| :--: | :----: | :--------------------------: |
|  &&  | 短路与 | 作用和&相同，但是有短路效果  |
| \|\| | 短路或 | 作用和\|相同，但是有短路效果 |

在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。

**注意事项：**

- 逻辑与 & ，无论左边真假，右边都要执行。
- 短路与 && ，如果左边为真，右边执行；如果左边为假，右边不执行。
- 逻辑或 | ，无论左边真假，右边都要执行。
- 短路或 || ，如果左边为假，右边执行；如果左边为真，右边不执行。
- 最常用的逻辑运算符：&&，||，!

```java
int x = 3;
int y = 4;
System.out.println((x++ > 4) & (y++ > 5)); // 两个表达都会运算
System.out.println(x); // 4
System.out.println(y); // 5
System.out.println((x++ > 4) && (y++ > 5)); // 左边已经可以确定结果为false，右边不参与运算
System.out.println(x); // 4
System.out.println(y); // 4
```

### 4.3.1.6 三元运算符

```java
格式：关系表达式 ? 表达式1 : 表达式2
```

范例：a > b ? a : b

计算规则：

1. 首先计算关系表达式的值
2. 如果值为true，表达式1的值就是运算结果
3. 如果值为false，表达式2的值就是运算结果

```java
int a = 10;
int b = 20;
int c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值
```

## 4.3.2 数据输入

我们目前程序中的数据都是固定的，程序不够灵活，为了提高程序的灵活性，我们也需要把数据的来源改进为输入数据。而我们目前所学的知识还比较少，不能够自己实现这个操作，只能够使用Java提供给我们的专门用于获取用户录入数据的类Scanner。

![image-20201231114357685](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185838.png)

### 4.3.2.1 Scanner使用的基本步骤

1. 导包

import java.util.Scanner;

导包的动作必须出现在类定义的上边

2. 创建对象

Scanner sc = new Scanner(System.in);

上面这个格式里面，只有sc是变量名，可以变，其他的都不允许变。

3. 接收数据

int i=sc.nextInt();

上面这个格式里面，只有 i 是变量名，可以变，其他的都不允许变。

```java
import java.util.Scanner;
public class ScannerDemo {
public static void main(String[] args) {
    //创建对象
    Scanner sc = new Scanner(System.in);
    //接收数据
    int x = sc.nextInt();
    //输出数据
    System.out.println("x:" + x);
  }
}
```

### 4.3.2.2 Random

作用：用于产生一个随机数

使用步骤：

① 导包

```java
importjava.util.Random;
导包的动作必须出现在类定义的上面
```

② 创建对象

```java
Random r = new Random();
上面这个格式里面，r是变量名，可以变，其他的都不允许变
```

③ 获取随机数

```java
int number = r.nextInt(10);//获取数据的范围：[0,10)包括0,不包括10
上面这个格式里面，number变量名，可以变，数字10可以变。其他的都不允许变
```


# 4.3.3 流程控制

在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。

![image-20201231115145162](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129184923.png)

## 4.3.3.1 顺序结构

顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。

顺序结构执行流程图：

![image-20201231115425777](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129184951.png)

## 4.3.3.2 分支结构

### 4.3.3.2.1 if语句

1. if语句格式 1

   ```java
   格式：
   if (关系表达式) {
     语句体; 
   }
   ```

执行流程：

① 首先计算关系表达式的值

② 如果关系表达式的值为true就执行语句体

③ 如果关系表达式的值为false就不执行语句体

④ 继续执行后面的语句内容

![image-20201231115806037](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185007.png)



```java
public class IfDemo {
    public static void main(String[] args) {
		System.out.println("开始");
		//定义两个变量
		int a = 10;
		int b = 20;
		//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b
		if(a == b) {
			System.out.println("a等于b");
			}
		//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c
		int c = 10;
		if(a == c) {
			System.out.println("a等于c");
		}
		System.out.println("结束");
	}
}
```

2.  if 语句格式 2

```java
格式：
if (关系表达式) {
  语句体1; 
} else {
  语句体2; 
}
```

执行流程：

① 首先计算关系表达式的值

② 如果关系表达式的值为true就执行语句体1

③ 如果关系表达式的值为false就执行语句体2

④ 继续执行后面的语句内容

![image-20201231115914030](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185041.png)



```java
public class IfDemo02 {
	public static void main(String[] args) {System.out.println("开始");
		//定义两个变量
		int a = 10;
		int b = 20;
		b = 5;
		//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b
		if(a > b) {
			System.out.println("a的值大于b");
		} else {
			System.out.println("a的值不大于b");
		}
		System.out.println("结束");
	}
}   
```



3. if 语句格式 3 

```java
格式：
if (关系表达式1) {
  语句体1; 
} else if (关系表达式2) {
  语句体2; 
} 
…
else {
  语句体n+1;
}
```

执行流程：

① 首先计算关系表达式1的值

② 如果值为true就执行语句体1；如果值为false就计算关系表达式2的值

③ 如果值为true就执行语句体2；如果值为false就计算关系表达式3的值

④ …

⑤ 如果没有任何关系表达式为true，就执行语句体n+1。

![image-20201231120054985](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185124.png)

示例：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日

```java
import java.util.Scanner;
public class IfDemo03 {
	public static void main(String[] args) {
		System.out.println("开始");
		// 需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个星期数(1-7)：");
		int week = sc.nextInt();
		if(week == 1) {
			System.out.println("星期一");
         } else if(week == 2) {
			System.out.println("星期二");
		} else if(week == 3) {
			System.out.println("星期三");
		} else if(week == 4) {
			System.out.println("星期四");
		} else if(week == 5) {
			System.out.println("星期五");
		} else if(week == 6) {
			System.out.println("星期六");
		} else {
			System.out.println("星期日");
		}
			System.out.println("结束");
	}
}
```

### 4.3.3.2.2 switch语句

```java
格式：
switch(表达式) {
	case 值1：
 		语句体1;
 		break;
  	case 值2：
		语句体2;
 		break;
 		 …
  	default： 
 		语句体n+1;
 		[break;]
}
```

格式说明：

表达式：取值为byte、short、int、char，JDK5以后可以是枚举，JDK7以后可以是String。

case：后面跟的是要和表达式进行比较的值。

break：表示中断，结束的意思，用来结束switch语句。

default：表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。

执行流程：

① 首先计算表达式的值。

② 依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。

③ 如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后程序结束掉。

![image-20201231125847906](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185147.png)

## 4.3.3.3 循环结构

特征：重复做某件事情,具有明确的开始和停止标志

![image-20201231115210731](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185203.png)



**循环结构的组成：**

初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样

条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去

循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情

条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去

**循环结构对应的语法：**

初始化语句： 这里可以是一条或者多条语句，这些语句可以完成一些初始化操作

条件判断语句：这里使用一个结果值为boolean类型的表达式，这个表达式能决定是否执行循环体。例如：a<3

循环体语句： 这里可以是任意语句，这些语句将反复执行

条件控制语句：这里通常是使用一条语句来改变变量的值，从而达到控制循环是否继续向下执行的效果。常见i++,i--这样的操作

### 4.3.3.3.1 for

格式：

```java
for(初始化语句;条件判断语句;条件控制语句) {
   循环体语句;
}
```

执行流程：

① 执行初始化语句

② 执行条件判断语句，看其结果是true还是false

       如果是false，循环结束
    
       如果是true，继续执行

③ 执行循环体语句

④ 执行条件控制语句

⑤ 回到 ② 继续

![image-20201231140930725](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185226.png)

### 4.3.3.3.2 while

完整格式：

```java
初始化语句;
while(条件判断语句) {
	循环体语句;
	条件控制语句;
}
```

执行流程：

① 执行初始化语句

② 执行条件判断语句，看其结果是true还是false

       如果是false，循环结束
    
       如果是true，继续执行

③ 执行循环体语句

④ 执行条件控制语句

⑤ 回到 ② 继续

![image-20201231141048249](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185247.png)

### 4.3.3.3.3 do…while

完整格式：

```java
初始化语句;
do {
  循环体语句;
  条件控制语句;
}while(条件判断语句);
```

执行流程：

① 执行初始化语句

② 执行循环体语句

③ 执行条件控制语句

④ 执行条件判断语句，看其结果是true还是false

	如果是false，循环结束
	
	如果是true，继续执行

⑤ 回到 ② 继续

![image-20201231141149842](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185305.png)

### 4.3.3.3.4 三种循环的区别

三种循环的区别：

- for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）
- do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）

for 和 while 的区别： 

- 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了
- 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用

死循环格式：

```java
for(;;) { } 
while(true) { } 
do{ }while(true);
```

while的死循环格式是最常用的

命令提示符窗口中Ctrl+C可以结束死循环

### 4.3.3.3.5 跳转控制语句

`continue：`

跳过某次循环体内容的执行。

注意：使用是基于条件控制的

用在循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行

`break：`

终止循环体内容的执行。

注意：使用是基于条件控制的

用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环

### 4.3.3.3.6 循环嵌套

循环嵌套概述：在循环中，继续定义循环

任何语句对外都可以看成是一句话，一句代码

分支语句中包含分支语句称为分支嵌套

循环语句中包含循环语句称为循环嵌套

语句结构：

- 顺序语句

以分号结尾，表示一句话的结束

![image-20201231141914208](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185331.png)

- 分支语句

一对大括号表示if的整体结构，整体描述一个完整的if语句

一对大括号表示switch的整体结构，整体描述一个完整的switch语句

![image-20201231141931405](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185346.png)

- 循环语句

一对大括号表示for的整体结构，整体描述一个完整的for语句

一对大括号表示while的整体结构，整体描述一个完整的while语句

do..while以分号结尾，整体描述一个完整的do..while语句

![image-20201231141944398](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185404.png)


# 4.3.4 方法

## 4.3.4.1 方法概述

方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集

![image-20201231153808065](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185541.png)

![image-20201231153857017](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185552.png)

注意：

- 方法必须先创建才可以使用，该过程称为方法定义

- 方法创建后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用

## 4.3.4.2 方法的定义和调用

定义格式： public static void 名 ( ) {

​    //方法体

 }

```java
范例：public static void isEvenNumber() {
     //方法体
 }
```

调用格式： 方法名 ( ) ;

```java
范例： isEvenNumber( ) ;
```

**注意：**

方法必须先定义后调用，否则程序将报错

## 4.3.4.3 带参数方法的定义和调用

格式：public static void 方法名 ( 参数 ) { … … }

```java
格式（单个参数）：public static void 方法名( 数据类型 变量名 ) { … … }
范例（单个参数）：public static void isEvenNumber(int number) { … … }

格式（多个参数）：public static void 方法名( 数据类型 变量名1 ，数据类型 变量名2 ，…… ) { … … }
范例（多个参数）：public static void getMax(int number1 ，int number2 ) { … … }
```

**注意：**

方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错

方法定义时，多个参数之间使用逗号( ，)分隔

**带参数方法调用**

格式： 方法名 ( 参数 ) ;

```java
格式（单个参数）： 方法名 ( 变量名/常量值 ) ;
范例（单个参数）： isEvenNumber（ 5 ） ;
格式（多个参数）： 方法名 ( 变量名1/常量值1 ，变量名2/常量值2 ) ;
范例（多个参数）： getMax （ 5，6 ） ; 
```

**注意：**

方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错

`形参和实参`

形参：方法定义中的参数等同于变量定义格式，例如：int number

实参：方法调用中的参数等同于使用变量或常量，例如： 10 number

![image-20201231154512591](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185610.png)

调用过程图解

![image-20201231155847783](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185626.png)

总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。

## 4.3.4.4 带返回值方法的定义和调用

1. 带返回值方法定义

格式：public static 数据类型       方法名 ( 参数 ) { 

​    	return数据 ;

 }

```java
范例1
    public static boolean isEvenNumber(int  number ) {
        return true;
 }
范例2：
    public static int getMax(int a,int b ) {
        return 100;
 }
```

**注意：**

方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错

2. 带返回值方法调用

```jade
格式1： 
方法名 ( 参数 ) ;
范例： 
isEvenNumber ( 5 ) ;
格式2： 
数据类型 变量名 = 方法名 ( 参数 ) ;
范例： 
boolean flag = isEvenNumber ( 5 ); 
```

**注意：**

方法的返回值通常会使用变量接收，否则该返回值将无意义

## 4.3.4.5 方法的注意事项

1. 方法不能嵌套定义

![image-20201231154845614](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185652.png)

2. void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据

![image-20201231154929609](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185714.png)

3. 方法的通用格式

```java
格式：
    public static 返回值类型 方法名(参数) {
   		方法体; 
   		return 数据 ;
 }
```

| public static |                            修饰符                            |
| :-----------: | :----------------------------------------------------------: |
|  返回值类型   | 方法操作完毕之后返回的数据的数据类型。如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return |
|    方法名     |                    调用方法时候使用的标识                    |
|     参数      |        由数据类型和变量名组成，多个参数之间用逗号隔开        |
|    方法体     |                       完成功能的代码块                       |
|    return     |     如果方法操作完毕，有数据返回，用于把数据返回给调用者     |

定义方法时，要做到两个明确

- 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型
- 明确参数：主要是明确参数的类型和数量

调用方法时

- void类型的方法，直接调用即可
- 非void类型的方法，推荐用变量接收调用

## 4.3.4.6 方法重载

方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同，类型不同或者数量不同

![image-20201231155418683](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185731.png)

重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式

重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载

![image-20201231155509444](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185747.png)

正确范例：

```java
public class MethodDemo {
	public static void fn(int a) {
	//方法体
	}
	public static int fn(double a) {
	//方法体
	}
}
public class MethodDemo {
	public static float fn(int a) {
	//方法体
	}
	public static int fn(int a , int b) {
	//方法体
	}
}
```

错误范例：

```java
public class MethodDemo {
	public static void fn(int a) {
	//方法体
	}
	public static int fn(int a) { /*错误原因：重载与返回值无关*/
	//方法体
	}
}
public class MethodDemo01 {
	public static void fn(int a) {
	//方法体
	}
}
public class MethodDemo02 {
	public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/
	//方法体
	}
}
```



## 4.3.4.7 方法的参数传递

对于基本数据类型的参数，形式参数的改变，不影响实际参数的值

结论依据：
每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失

![image-20201231160231249](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185805.png)

对于引用类型的参数，形式参数的改变，影响实际参数的值

结论依据：
引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果

![image-20201231160301938](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185820.png)


# 4.3.5 程序练手

## 4.3.5.1 减肥计划

需求：输入星期数，显示今天的减肥活动

​     周一：跑步

​     周二：游泳   

​     周三：慢走

​     周四：动感单车  

​     周五：拳击   

​     周六：爬山

​     周日：好好吃一顿

思路：

① 键盘录入一个星期数，用一个变量接收

② 对星期数进行判断，这里用 switch 语句实现

③ 在对应的语句控制中输出对应的减肥活动

## 4.3.5.2 逢七过

需求：朋友聚会的时候可能会玩一个游戏：逢七过。规则是：从任意一个数字开始报数，当你要报的数字包含7或者是7的倍数时都要说：过。为了帮助大家更好的玩这个游戏，这里我们直接在控制台打印出1-100之间的满足逢七必过规则的数据。

这样，大家将来在玩游戏的时候，就知道哪些数据要说：过。

思路：

① 数据在1-100之间，用for循环实现数据的获取

② 根据规则，用if语句实现数据的判断：要么个位是7，要么十位是7，要么能够被7整除

x%10 == 7 x/10%10 == 7 x%7==0

③ 在控制台输出满足规则的数据

## 4.3.5.3 不死神兔

需求：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第二十个月的兔子对数为多少？

找规律：

第一个月：1

第二个月：1

第三个月：2

第四个月：3

第五个月：5

…

数据连起来：1,1,2,3,5…

规律：

从第三个数据开始，每一个数据是前两个数据之和。

第1个，第2个数据是已知的。



用数组模拟：

arr [0] = 1;

arr [1] = 1;

arr [2] = arr [0] + arr [1];

arr [3] = arr [1] + arr [2];

......

思路：

① 为了存储多个月的兔子对数，定义一个数组，用动态初始化完成数组元素的初始化，长度为20

② 因为第1个月，第2个月兔子的对数是已知的，都是1，所以数组的第1个元素，第2个元素值也都是1

③ 用循环实现计算每个月的兔子对数

for(int x=?; x<?; x++){
    规律
  }

④ 输出数组中最后一个元素的值，就是第20个月的兔子对数

## 4.3.5.4 百钱百鸡

需求：我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？

![image-20210101112944551](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185857.png)

分析：

假设鸡翁x只，鸡母y只，鸡雏z只，则下面的式子是成立的

x + y+ z = 100;

5\*x + 3\*y + z/3 = 100;



如果单独只看一种鸡型，则下面的式子是成立的

0<=x<=20

0<=y<=33

0<=z<=100

使用穷举法就可以罗列出x，y，z的值。

思路：

① 第1层循环，用于表示鸡翁的范围，初始化表达式的变量定义为 x=0，判断条件是x<=20

② 第2层循环，用于表示鸡母的范围，初始化表达式的变量定义为 y=0，判断条件是y<=33

③ 这个时候，用于表示鸡雏的变量 z = 100 – x – y

④ 判断表达式 z%3==0 和表达式 5\*x + 3\*y + z/3 = 100 是否同时成立，如果成立，输出对应的 x，y，z 的值，就是对应的鸡翁，鸡母，鸡雏的值

## 4.3.5.5 数组元素求和

需求：有这样的一个数组，元素是{68,27,95,88,171,996,51,210}。求出该数组中满足要求的元素和，要求是：求和的元素个位和十位都不能是7，并且只能是偶数

思路：

① 定义一个数组，用静态初始化完成数组元素的初始化

② 定义一个求和变量，初始值是0

③ 遍历数组，获取到数组中的每一个元素

④ 判断该元素是否满足条件，如果满足条件就累加

arr[x]%10 != 7 arr[x]/10%10 != 7 arr[x]%2 == 0

⑤ 输出求和变量的值

## 4.3.5.6 数组内容相同 

需求：设计一个方法，用于比较两个数组的内容是否相同

思路：

① 定义两个数组，分别使用静态初始化完成数组元素的初始化

② 定义一个方法，用于比较两个数组的内容是否相同

返回值类型：boolean

参数：int[] arr, int[] arr2

③ 比较两个数组的内容是否相同，按照下面的步骤实现就可以了

首先比较数组长度，如果长度不相同，数组内容肯定不相同，返回false

其次遍历，比较两个数组中的每一个元素，只要有元素不相同，返回false

最后循环遍历结束后，返回true

④ 调用方法，用变量接收

⑤ 输出结果

## 4.3.5.7 查找 

需求：已知一个数组 arr = {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引，并在控制台输出找到的索引值。

![image-20210101113700024](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185912.png)

分析：

键盘录入一个数据后，让这个数据和数组中的每一个元素进行比较，如果数据值相等， 返回该数据值对应的索引即可。

但是，假如录入了一个数组中不存在的数据，这个时候，就没有任何内容输出了，很明显是有问题的，在实际开发中，如果对应的索引不存在，我们一般都是返回一个负数，而且经常用-1来表示。

思路：

① 定义一个数组，用静态初始化完成数组元素的初始化

② 键盘录入要查找的数据，用一个变量接收

③ 定义一个索引变量，初始值为-1

④ 遍历数组，获取到数组中的每一个元素

⑤ 拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环

⑥ 输出索引变量

## 4.3.5.8 反转

需求：已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换， 

​     交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。

![image-20210101113910340](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185930.png)

分析：

第1个元素和最后一个元素交换

第2个元素和倒数第二个元素交换

第3个元素和倒数第三个元素交换

…

![image-20210101124255946](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129185952.png)

![image-20210101124312851](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129190006.png)

![image-20210101124328944](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129190014.png)

思路：

① 定义一个数组，用静态初始化完成数组元素的初始化

② 循环遍历数组，这一次初始化语句定义两个索引变量，判断条件是开始索引小于等于结束索引

③ 变量交换

④ 遍历数组

## 4.3.5.9 评委打分

需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。

​     选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。

思路：

① 定义一个数组，用动态初始化完成数组元素的初始化，长度为6

② 键盘录入评委分数

③ 由于是6个评委打分，所以，接收评委分数的操作，用循环改进

④ 定义方法实现获取数组中的最高分(数组最大值)，调用方法

⑤ 定义方法实现获取数组中的最低分(数组最小值) ，调用方法

⑥ 定义方法实现获取数组中的所有元素的和(数组元素求和) ，调用方法

⑦ 按照计算规则进行计算得到平均分

⑧ 输出平均分


# 4.3.6 包

## 4.3.6.1 包

### 4.3.6.1.1 包的概述和使用

其实就是文件夹

作用：对类进行分类管理

包的定义格式

- 格式：package 包名;(多级包用.分开)
- 范例：package com.itheima;



带包的Java类编译和执行

- 手动建包：

  按照以前的格式编译java文件 javac HelloWorld.java

  手动创建包 在E盘建立文件夹com,然后在com下建立文件夹itheima

  把class文件放到包的最里面 把HelloWorld.class文件放到com下的itheima这个文件夹下

  带包执行 java com.itheima.HelloWorld

- 自动建包：javac –d . HelloWorld.java java com.itheima.HelloWorld

## 4.3.6.2 导包

### 4.3.6.2.1 导包的概述和使用

使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了

为了简化带包的操作，Java就提供了导包的功能

导包的格式

- 格式：import 包名;
- 范例：import cn.itcast.Teacher
